Вступ
--
```python3 main.py```

У консоль вводите саме номер потрібної вам задачі, після цього ви отримаєте сам результат. Якщо ви не отримали результат одразу, скоріш за все вам треба прочитати умову задачі, або ж пояснення знизу.

Задача 1
---
Код:
```
def calculateRectArea(a: int, b: int):
    return a*b

def calculateRectSum(a: int, b: int):
    return 2*(a+b)
```
```calculateRectArea``` приймає два аргументи, a і b, які вважаються довжиною і шириною прямокутника. І результує просто їх добуток, тобто площу прямокутника.

```calculateRectSum``` - периметр.

Задача 2
---
```
import math

def geom(a: int, b:int):
    return math.sqrt(a*b)
```
Для квадратного корню використана функцію ```math.sqrt```

Задача 3
---
```
def calculRectArea(x1:int, y1:int, x2: int, y2:int):
    if x1 == x2 or y1 == y2:
        return 0
    a = abs(x1) + abs(x2)
    b = abs(y1) + abs(y2)
    return a*b

def calculRectSum(x1:int, y1:int, x2: int, y2:int):
    if x1 == x2 or y1 == y2:
        return 0
    a = abs(x1) + abs(x2)
    b = abs(y1) + abs(y2)
    return 2 * (a+b)
```
Для того, щоб розрахувати площу прямокутника нам потрібні дві його сторони відповідно. Через те, що декартова система координат представляє і від'ємні числа також, беремо модуль з них.

Перша функція для площі, інша для периметра

Задача 4
---
```
def calcPairNumbers(a: int):
    if a % 1 == 0:
        if a % 2 == 0:
            return True
    
    return False
```
З допомогою ```a % 1``` я перевіряю, чи є число ціле, і відповідно ```a % 2``` парне.

Задача 5
---
```
def calc5a(a: int, b: int, c: int):
    if a % 1 == 0 and b % 1 == 0 and c % 1 == 0:
        if a < b and b < c:
            return True
    
    return False

def calc5b(a: int, b: int, c: int):
    if a % 1 == 0 and b % 1 == 0 and c % 1 == 0:
        if a > 0 or b > 0 or c > 0:
            return True
    
    return False

def calc5c(a: int, b: int, c: int):
    if a % 1 == 0 and b % 1 == 0 and c % 1 == 0:
        positive_count = 0
        if a > 0:
            positive_count += 1
        if b > 0:
            positive_count += 1
        if c > 0:
            positive_count += 1

        if positive_count == 1:
            return True
            
    return False
```
Так як за умовою задачі вимагається 3 розв'язки, я розписав 3 функції. Усі вони перевіряють ```a```, ```b``` і ```c``` на цілістність, це вимагається за умовою.

У останній функції змінна аккумулює число позитивних чисел, та інкрементує його якщо таке було знайдено. Якщо їх число дорівнює одиниці, повертаємо True.

Задача 6
---
```
chess_board = []

for i in range(8):
    row = []
    for j in range(8):
        row.append(" ")
    chess_board.append(row)

for i in range(8):
    for j in range(8):
        if (i + j) % 2 == 0:
            chess_board[i][j] = "0" 
        else:
            chess_board[i][j] = "1"

def check_for_white(x: int, y: int):
    if chess_board[7-x][y-1] == "0":
        return True
    else:
        return False
```
Цей код створює шахову дошку та має функцію `check_for_white`, яка перевіряє, чи біла клітинка (за умовою, що "0" представляє білу клітину) знаходиться на заданих координатах `(x, y)`.

Ось пояснення кожної частини коду:

1. Створення шахової дошки `chess_board`:
   - Це двовимірний список (список списків), який представляє шахову дошку розміром 8x8.
   - Перший цикл `for` створює 8 рядків, і для кожного рядка створюється порожній рядок, який додається до `row`.
   - Другий цикл `for` заповнює кожен рядок 8 клітинками з пробілами, створюючи порожню дошку.

2. Заповнення дошки клітинками "0" і "1":
   - Після створення порожньої дошки двома вкладеними циклами `for`, виконується подальший цикл `for`.
   - У цьому циклі `for`, здійснюється перевірка суми індексів `i` і `j`. Якщо сума є парною, то клітинці присвоюється значення "0", в іншому випадку - "1".
   - Це робить змінну `chess_board` представницею шахової дошки з чергуванням білих і чорних клітин.

3. Функція `check_for_white(x: int, y: int)`:
   - Ця функція перевіряє, чи є клітина з координатами `(x, y)` білою, шукаючи відповідну клітинку у двовимірному списку `chess_board`.
   - Зверніть увагу, що функція використовує інверсію координати `x` (зменшення на 1), оскільки у списку рядки нумеруються з 0, а функція приймає `x` у діапазоні від 1 до 8.
   - Якщо клітина біла (має значення "0"), функція повертає `True`, інакше - `False`.

Отже, цей код створює шахову дошку, заповнює її чергуючими білими і чорними клітинами, і надає можливість перевірити, чи біла клітинка знаходиться на заданих координатах.

Задача 7
---
```
def is_queen_move(x1, y1, x2, y2):
    if x1 == x2 or y1 == y2 or abs(x1 - x2) == abs(y1 - y2):
        return True
    else:
        return False
```

Майже увесь код був взятий з задачі 6.

Ця функція, `is_queen_move`, призначена для перевірки, чи може фігура королеви здійснити хід з позиції `(x1, y1)` до позиції `(x2, y2)` на шаховій дошці. Ось її пояснення:

- Перевірка горизонтального руху: `x1 == x2` або `y1 == y2`. Якщо `x1` дорівнює `x2`, це означає, що королева рухається по вертикальній лінії. Якщо `y1` дорівнює `y2`, це означає, що королева рухається по горизонталі. В такому випадку функція повертає `True`.

- Перевірка діагонального руху: `abs(x1 - x2) == abs(y1 - y2)`. Ця умова перевіряє, чи королева рухається по діагоналі, порівнюючи різницю між `x`-координатами і `y`-координатами. Якщо ці різниці однакові, то це означає діагональний рух. В такому випадку функція також повертає `True`.

Якщо жодна з цих трьох умов не виконується, функція повертає `False`, що означає, що королева не може здійснити такий хід. Усі ці перевірки враховують правила руху королеви на шаховій дошці, де вона може рухатися по вертикалях, горизонталях і діагоналях.

Задача 8
---
```
def solveTask8(a: int, b: int):
    if b < a:
        print("B має бути більше А")
    else:
        count = 0
        print("Числа:")

        for number in range(a, b + 1):
            print(number)
            count += 1

        print("К-сть чисел у діапазоні", count)
```
За умовою a > b, тому якщо вихідні дані проходять цю умову:
За допомогою аккумулювання рахуємо кількість чисел у діапазоні та перераховуємо їх.

Задача 9
---
```
def get_reverse(N: int):
    if N <= 0:
        print("Число має бути більше нуля.")
    else:
        reversed_number = 0
        original_number = N

        while N > 0:
            last_digit = N % 10

            reversed_number = reversed_number * 10 + last_digit

            N = N // 10

        print("Початкове: ", original_number, "справа наліво: ", reversed_number)
```

1. Функція перевіряє, чи вхідне число `N` менше або дорівнює 0. Якщо так, виводиться повідомлення про помилку.

2. Якщо `N` більше нуля, створюється змінна `reversed_number` для збереження оберненого числа, і змінна `original_number` для збереження початкового числа.

3. Використовується цикл `while`, який працює, поки `N` більше 0. У цьому циклі:
   - Отримується остання цифра числа `N` за допомогою операції `% 10`.
   - Ця остання цифра додається до змінної `reversed_number`, яка відповідає за обернене число.
   - Остання цифра видаляється з числа `N` за допомогою операції `// 10`.

4. Після завершення циклу виводяться два числа: початкове `original_number` і обернене `reversed_number`, де цифри розташовані справа наліво.

Задача 10
---
```
def solveTask10(arr: []):
    average = sum(arr) / len(arr)

    result_array = []

    for element in arr:
        if element > average:
            result_array.append(element - 18)
        else:
            result_array.append(element)
    return result_array

```
Ця функція `solveTask10(arr: [])` отримує список `arr` і виконує наступні дії:

1. Знаходить середнє арифметичне всіх елементів у вхідному списку `arr` за допомогою виразу `average = sum(arr) / len(arr)`.

2. Створює порожній список `result_array`, який буде використовуватися для збереження результатів обробки вхідного списку.

3. Перебирає елементи вхідного списку `arr` за допомогою циклу `for element in arr` і виконує наступні дії для кожного елемента:

   - Перевіряє, чи є елемент більшим за середнє арифметичне (`average`). Якщо так, то віднімає від нього число 18 (`element - 18`) і додає результат до `result_array`.
   
   - Якщо елемент менший або рівний середньому, то просто додає цей елемент до `result_array`.

4. Повертає список `result_array`, який містить оброблені значення вхідного списку `arr`.

Задача 11
---
```
def solveTask11(N: int):
    if N <= 1:
        print("Число має бути більше 1")
    else:
        is_prime = True  # Предполагаем, что число простое

        for i in range(2, N):
            if N % i == 0:
                is_prime = False  # Если есть делитель, то число не простое
                break

        if is_prime:
            print("число {} просте".format(N))
        else:
            print("число {} не просте".format(N))
```
1. Спочатку функція перевіряє, чи `N` менше або дорівнює 1. Якщо так, вона виводить повідомлення "Число має бути більше 1", оскільки прості числа починаються з 2.

2. Якщо `N` більше 1, то функція встановлює прапорець `is_prime` в значення `True`, що означає, що вона передбачає, що число є простим.

3. Далі використовується цикл `for`, який перебирає всі можливі дільники числа `N` від 2 до `N-1`. Для кожного `i` в цьому діапазоні перевіряється, чи `N` ділиться без залишку на `i`. Якщо така дільність виявляється, це означає, що `N` не є простим числом, і прапорець `is_prime` встановлюється в `False`. Після цього цикл завершується за допомогою оператора `break`.

4. Після завершення циклу перевіряється значення прапорця `is_prime`. Якщо `is_prime` дорівнює `True`, то виводиться повідомлення "число {} просте", в якому вставляється значення `N`.

5. Якщо `is_prime` дорівнює `False`, то виводиться повідомлення "число {} не просте", в якому також вставляється значення `N`.

Задача 12
---
```
import math


def func(x: float, y: float, z: float):
    up = x + z*z + y/4
    down = z*(y-2) + math.pow(z*z + 4, -1)
    return up/down

```
Ця функція `func(x: float, y: float, z: float)` приймає три аргументи типу float: `x`, `y` і `z`, і виконує певні обчислення за вказаною формулою. Ось її пояснення:

1. Спочатку обчислюється чисельник (`up`):
   - `up` обчислюється як сума `x`, `z` в квадраті і `y` поділити на 4.

2. Далі обчислюється знаменник (`down`):
   - `down` обчислюється як добуток `z`, різниця `y` і 2, та обернена величина `(z*z + 4)`.

3. Функція повертає результат обчислення `up/down`, тобто відношення чисельника до знаменника.

Зауважте, що у функції використовується функція `math.pow(z*z + 4, -1)`, яка обчислює обернену величину `(z*z + 4)`. Ця функція знаходиться в модулі `math`.

Отже, ця функція призначена для обчислення значення за вказаною математичною формулою на основі трьох вхідних чисел `x`, `y` і `z`.

Задача 13
---
```
def first13():
    name = input()
    surname = input()
    phone = input()

    if len(phone) != 0:
        try:
            int(phone) # phone number can be converted to int
        except:
            return "Неправильний номер телефону, введіть цифри"
    
    if len(name) == 0:
        name = "false"
    if len(surname) == 0:
        surname = "false"
    if len(phone) == 0:
        phone = "false"
    print(name, surname, phone)

    if name != "false" and surname != "false" and phone != "false":
        return "Спасибі"
    else:
        return "Не залишайте жодні поля порожніми"

def second13():
    name = input()
    surname = input()
    phone = input()

    if len(phone) != 0:
        try:
            int(phone) # phone number can be converted to int
        except:
            return "Неправильний номер телефону, введіть цифри"
        
    if len(name) == 0:
        name = "false"
    if len(surname) == 0:
        surname = "false"
    if len(phone) == 0:
        phone = "false"
    print(name, surname, phone)

    if name != "false" or surname != "false" or phone != "false":
        return "Спасибі"
    else:
        return "Не залишайте всі поля порожніми"

def third13():
    name = input()
    surname = input()
    phone = input()

    
    if len(name) == 0:
        name = "false"
    if len(surname) == 0:
        surname = "false"
    if len(phone) == 0:
        phone = "false"
    print(name, surname, phone)
    
    if name != "false" or surname != "false":
        return "Спасибі"
    else:
        return "Не залишайте всі поля порожніми"
    
```
1. Функція `first13()`:
   - Перша функція очікує введення користувачем імені (`name`), прізвища (`surname`) і номеру телефону (`phone`).
   - Вона перевіряє, чи `phone` не порожній і спробує перетворити його в ціле число. Якщо не вдасться, то поверне повідомлення про помилку.
   - Якщо `name`, `surname` або `phone` порожні, вони заповнюються значеннями "false".
   - Функція виводить введені дані, а потім перевіряє, чи всі три поля (`name`, `surname` і `phone`) не дорівнюють "false". Якщо так, повертає "Спасибі", інакше повертає "Не залишайте жодні поля порожніми".

2. Функція `second13()`:
   - Друга функція має схожий функціонал, але вона перевіряє, чи хоча б одне поле (`name`, `surname` або `phone`) не дорівнює "false". Якщо хоча б одне поле заповнене, то повертає "Спасибі", інакше повертає "Не залишайте всі поля порожніми".

3. Функція `third13()`:
   - Третя функція обробляє введені дані, виводить їх, і перевіряє, чи хоча б одне з полів (`name` або `surname`) не дорівнює "false". Якщо хоча б одне поле заповнене, то повертає "Спасибі", інакше повертає "Не залишайте всі поля порожніми".

Задача 14
---
```
def solveTask14():
    for counter in range(5):
        counter = input()
        if counter == "5":
            print("маладєц")
            break
        else:
            continue
```
1. Цикл `for counter in range(5):` виконується п'ять разів, оскільки діапазон `range(5)` включає числа від 0 до 4.

2. У кожній ітерації циклу користувачеві надається можливість ввести дані (введення здійснюється за допомогою функції `input()`), і ці дані зберігаються в змінній `counter`.

3. Потім функція перевіряє, чи введене значення `counter` дорівнює рядку "5". Якщо це так (тобто користувач ввів "5"), то виводиться повідомлення "маладєц", і цикл завершується за допомогою оператора `break`.

4. Якщо користувач ввів будь-яке інше значення, то цикл продовжується з наступною ітерацією за допомогою оператора `continue`. Це означає, що користувачу буде надано ще одну можливість ввести дані.

Задача 15
---
Ця функція `task15()` містить безкінечний цикл `while`, який призначений для знаходження і виведення всіх чисел, менших за 100, які діляться на 13 без залишку. Ось її пояснення:

1. Змінна `number` ініціалізується значенням 100, що є початковим значенням для пошуку чисел.

2. Починається безкінечний цикл `while True:`, оскільки умова завершення циклу не визначена.

3. У тілі циклу перевіряється, чи `number` менше за 100. Якщо це так, то виконується наступна перевірка.

4. У внутрішній перевірці перевіряється, чи `number` ділиться на 13 без залишку, тобто `number % 13 == 0`. Якщо ця умова виконується, то число виводиться на екран за допомогою функції `print(number)`.

5. Після цього значення `number` зменшується на 1 за допомогою `number -= 1`.

**Важливо! У описі задачі вимагалось використовування ```range(start, end, step)```. Нажаль це не є можливим, бо за умовою задачі ми маємо перебирати числа менше 100, тобто від 100 прямо у нескінченність. Тому ця функція буде йти у від'ємну нескінченність.**

Задача 16
---
```
first_string = "Один"
second_string = "два"

combined_string = first_string + second_string


multiplied_string = first_string * 10


original_string = "Пінгвіни люблять морозиво"
inserted_character = "*"
position = 6  # Позиція, на яку ми хочемо вставити символ
modified_string1 = original_string[:position] + inserted_character + original_string[position:]


original_string = "Суржики пихають пиво"
modified_string2 = original_string[:-1] + "X"  # Замінюємо останній символ на "X"
```
Цей фрагмент коду містить операції з рядками. Давайте розглянемо їх по черзі:

1. `combined_string = first_string + second_string`: Ця операція об'єднує два рядки `first_string` і `second_string` в один рядок `combined_string`. У результаті `combined_string` буде містити "Одиндва".

2. `multiplied_string = first_string * 10`: Ця операція дублює рядок `first_string` 10 разів і зберігає результат у `multiplied_string`. Тобто, `multiplied_string` буде містити "ОдинОдинОдинОдинОдинОдинОдинОдинОдинОдин".

3. `modified_string1 = original_string[:position] + inserted_character + original_string[position:]`: Ця операція вставляє символ `inserted_character` (зірочку) у рядок `original_string` на позицію `position`. Результат зберігається у `modified_string1`. Це виглядає так: "Пінгв*іни люблять морозиво". Зверніть увагу, що рядок розділено на дві частини і вставлено символ між ними.

4. `modified_string2 = original_string[:-1] + "X"`: Ця операція замінює останній символ рядка `original_string` на "X". Результат зберігається у `modified_string2`. Тобто, якщо `original_string` був "Суржики пихають пиво", то `modified_string2` буде "Суржики пихають пивX".




**Ось і все! Дякую за те що читали :) Сподіваюсь, ви оцінете мою роботу хочаб на трійку!!!!**
